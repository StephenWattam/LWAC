#!/usr/bin/env ruby
require 'rubygems'
if __FILE__ != $0 then
  $stderr.puts "This script is intended to be run directly."
  exit(1)
end
require './lib/shared/launch_tools.rb'

check_gems('marilyn-rpc', 'curb', 'eventmachine')

Dir.glob(File.join(File.dirname(__FILE__), "lib", "shared", "*.rb")).each{|x| require x}
Dir.glob(File.join(File.dirname(__FILE__), "lib", "client", "*.rb")).each{|x| require x}

require 'marilyn-rpc'
require 'eventmachine'
require 'yaml'
require 'timeout'


class DownloadClient
  def initialize(config)
    # Start up the client
    @config = config

    # Generate a UUID and ensure the workers know it
    generate_uuid
    @config[:worker_pool][:client_uuid] = @uuid

    # Reset the reconnection timer to the minimum wait
    @reconnect_timer = @config[:network][:minimum_reconnect_time]

    # Current working links
    @links        = []
    @datapoints   = []

    # Should we really care about being able to contact the server?
    @shutdown     = false

    # Start the log with UUID info.
    $log.info "Client started with UUID: #{@uuid}"
  end

  # Contact the server for work, do it, then send it back ad infinitum.
  #
  # Raise SIGINT to stop.
  def work
    loop do 
      # Get a batch from the server
      acquire_batch

      # Process
      process_links 

      # Send completed points back to the server
      send_batch
    end

  rescue SignalException => se
    $log.fatal "Caught signal!"
    @shutdown = true
    $log.fatal "Contacting the server to cancel links..."
    cancel_batch
    $log.fatal "Done."
    return
  end



private

  # Actually download the links
  # This starts up a worker pool, and waits until they are done.
  def process_links
    $log.info "Creating worker pool and starting work..."
    pool = WorkerPool.new(@config[:worker_pool], @links)
    pool.init_workers
    pool.work
    @datapoints = pool.wait_and_get_datapoints
    $log.info "Downloaded.  Checking in complete links..."
    @datapoints.each{|dp| @links.delete(dp.link) }
    pool.summarise
  rescue SignalException => se
    $log.fatal "Caught signal!"

    # Clear up any worker threads and close their connections.
    if pool then
      $log.fatal "Currently processing links.  Killing workers..."
      pool.kill_workers
      $log.fatal "Done."
    end

    # Pass the exception up to halt the whole thing
    raise se
  end

  # Grab a batch of links from the server
  def acquire_batch
    loop do
      @links = connect do |s|
        s.check_out(@uuid, @config[:client][:batch_capacity])
      end

      # If the server tells us to back off, so do.
      if(@links.class == Fixnum)
        $log.info "Sleeping for #{@links}s until #{Time.now + @links} at the server's request."
        sleep([@links, @config[:network][:maximum_reconnect_time]].min)
      elsif(@links.class == Array)
        $log.info "Received #{@links.length}/#{@config[:client][:batch_capacity]} links from server."
        return
      else
        $log.warn "Received unrecognised return from server of type: #{@links.class}.  Retrying..."
      end
    end
  end

  # Send the batch of datapoints we have currently.
  # Sends in "chunks" of :check_in_rate 
  def send_batch
    while(@datapoints.length > 0) do
      @pending    = @datapoints.slice!(0, @config[:client][:check_in_rate])
      $log.info "Sending #{@pending.length} datapoints (~#{(Marshal.dump(@pending).length.to_f / 1024.0 / 1024.0).round(2)}MB) to server..."
      connect do |s|
        s.check_in(@uuid, @pending)
      end
      $log.debug "Done."
    end
  end

  # Cancel the batch of links we currently have checked out.
  # This atomically aborts these links and frees them up for other clients.
  def cancel_batch
    return if(@links.class == Fixnum) # just in case we bail whilst waiting

    $log.info "Cancelling at least #{@links.length} links."
    connect do |s|
      s.cancel(@uuid)
    end
  end

  # Connect to the server, using backoff as described in the config file
  def connect(&block)
    $log.debug "Connecting to server #{@config[:server][:address]}:#{@config[:server][:port]}..."

    client = nil
    while(not client) do
      begin
        # Attempt to connect with the connect_timeout set
        Timeout::timeout(@config[:network][:connect_timeout]){
          client = MarilynRPC::NativeClient.connect_tcp( @config[:server][:address], @config[:server][:port] )
        }

      # On error
      rescue Exception => e
        
        # Simply quit if we have been told to shut down
        return if @shutdown

        # Network Errors
        case e
        when Timeout::Error, Errno::ECONNREFUSED, Errno::ECONNRESET, Errno::EHOSTUNREACH
          # Increase reconnect timer gradually up to the limit set in the config file
          @reconnect_timer = [@reconnect_timer + @config[:network][:connect_failure_penalty], @config[:network][:maximum_reconnect_time]].min
        else
          # Continue to pass error up
          raise e
        end

        # Warn the user and wait until it's time to try again
        $log.error "Failed to connect (#{e}).  Reconnecting in #{@reconnect_timer}s."
        sleep(@reconnect_timer)
      end
    end

    # Reset the backoff timer now we have connected successfully
    @reconnect_timer = @config[:network][:minimum_reconnect_time]

    # Start doing things!  Register as a client
    download_service = client.for(:downloader)
    $log.debug "Done.  Yielding to perform actions."

    # Then yield the service to our caller
    response = nil
    begin
      response = yield(download_service)
    rescue Exception => e
      $log.error "Exception: #{e}"
      $log.debug e.backtrace.join("\n")
    end
    
    # When done, disconnect
    client.disconnect
    $log.debug "Disconnected."

    return response
  end

  # Create this client's ID.  
  # Must be persistent across instances, but not across machines.
  def generate_uuid
    require 'socket'
    # TODO: make this ID based more on IP address, and/or make it more readable
    @uuid = @config[:client][:uuid_salt] + "_" + Digest::MD5.hexdigest("#{Socket.gethostname}#{@config[:client][:uuid_salt]}").to_s 
  end

end




# -----------------------------------------------------------------------------
  
# Load config and logs using launch_tools
config = load_config 

# Start the client going
dc = DownloadClient.new(config)

# download
dc.work


