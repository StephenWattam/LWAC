#!/usr/bin/env ruby

# Import links from one-link-per-line into the given database
db_file                               = ARGV[0]
list                                  = ARGV[1]
create                                = ARGV[2].to_s.length != 0

# Read the list file
# Tools to speed up the database, at some cost to data reliability in the event
# of a crash
#
# See http://www.sqlite.org/pragma.html for a full list.
# The names of these keys are taken from http://sqlite-ruby.rubyforge.org/
#
SQLITE_PRAGMA   = {"cache_size"   => 20000,
                   "synchronous"  => 0,
                   "temp_store"   => 2 }



# Force encoding to UTF-8 on import?
FIX_ENCODING = true

# output progress every n links
NOTIFY_PROGRESS = 1023


SCHEMA_PATH     = File.join(File.dirname(__FILE__), "resources", "schema.sql")

# -----------------------------------------------------------------------------------------------------
if(ARGV.length < 2)
  puts "USAGE: "
  puts "  ruby link_import.rb DBFILE LINKFILE [create]"
  puts ""
  puts "    DBFILE : A sqlite3 database file to use as metadata storage."
  puts "   LINKFILE: The file to load one-link-per-line from.."
  puts "     create: Include this word to create the db.  Will overwrite any other db there."
  puts ""
  exit(1)
end


# -----------------------------------------------------------------------------------------------------
require 'sqlite3'
# -----------------------------------------------------------------------------------------------------
if create then
  puts "Creating db at #{db_file} using schema from #{SCHEMA_PATH}..."
  SQLite3::Database.new(db_file) do |db|
    schema = File.open(SCHEMA_PATH).read
    db.execute(schema)
  end
  puts "Done!"
end

# -----------------------------------------------------------------------------------------------------


# Generically handles an sqlite3 database
class DatabaseConnection
  attr_reader :dbpath

  def initialize(dbpath, transaction_limit=100, pragma={})
    @transaction        = false
    @transaction_limit  = transaction_limit
    @transaction_count  = 0
    connect( dbpath )
    configure( pragma )
  end

  def close
    disconnect
  end

  def results_as_hash= bool
    @db.results_as_hash = bool
  end

  def results_as_hash
    @db.results_as_hash
  end


  # Run an SQL insert call on a given table, with a hash of data.
  def insert(table_name, value_hash)
    raise "Attempt to insert 0 values into table #{table_name}" if value_hash.length == 0

    escaped_values = [] 
    value_hash.each{|k, v| escaped_values << escape(v) }

    return execute("insert into `#{table_name}` (#{value_hash.keys.join(",")}) values (#{escaped_values.join(",")});")
  end


  # Run an SQL insert call on a given table, with a hash of data.
  def update(table_name, value_hash, where_conditions = "")
    # Compute the WHERE clause.
    where_conditions = "where #{where_conditions}" if where_conditions.length > 0

    # Work out the SET clause
    escaped_values = []
    value_hash.each{|k, v| 
      escaped_values << "#{k}='#{escape(v)}'" 
    }

    return execute("update `#{table_name}` set #{escaped_values.join(", ")} #{where_conditions};")
  end


  # Select certain fields from a database, with certain where field == value.
  #
  # Returns a record set (SQlite3)
  # 
  # table_name is the name of the table from which to select.
  # fields_list is an array of fields to return in the record set
  # where_conditions is a string of where conditions. Careful to escape!!
  def select(table_name, fields_list, where_conditions = "")
    where_conditions = "where #{where_conditions}" if where_conditions.length > 0
    return execute("select #{fields_list.join(",")} from `#{table_name}` #{where_conditions};")
  end


  # Delete all items from a table
  def delete(table_name, where_conditions = "")
    where_conditions = "where #{where_conditions}" if where_conditions.length > 0
    return execute("delete from `#{table_name}` #{where_conditions};")
  end


  # Execute a raw SQL statement
  # Set trans = false to force and disable transactions
  def execute(sql, trans=true)
    start_transaction if trans
    end_transaction if @transaction and not trans 

    #puts "DEBUG: #{sql}"

    # run the query
    #puts "<#{sql.split()[0]}, #{trans}, #{@transaction}>"
    res = @db.execute(sql)
    @transaction_count += 1 if @transaction

    # end the transaction if we have called enough statements
    end_transaction if @transaction_count > @transaction_limit

    return res
  end
  
private
  def escape( str )
    "'#{SQLite3::Database::quote(str.to_s)}'"
  end

  def connect( dbpath )
    # Reads data from the command line, and loads it
    raise "Cannot access database #{dbpath}" if not File.readable_real?(dbpath)
    
    # If the db file is readable, open it.
    @dbpath = dbpath
    @db = SQLite3::Database.new(dbpath)
  end

  def configure( pragma )
    pragma.each{|pragma, value| 
      execute("PRAGMA #{pragma}=#{value};", false) # execute without transactions
    }
  end

  def disconnect
    end_transaction if @transaction
    @db.close
  end
  
  def start_transaction
    if not @transaction
      @db.execute("BEGIN TRANSACTION;") 
      @transaction = true
    end
  end

  def end_transaction
    if @transaction then
      @db.execute("COMMIT TRANSACTION;") 
      @transaction_count = 0
      @transaction = false
    end
  end
end




# -----------------------------------------------------------------------------------------------------

db = DatabaseConnection.new(db_file, 100, SQLITE_PRAGMA)

# -----------------------------------------------------------------------------------------------------
begin
  puts "Importing links..."
  count = 0;
  File.read(list).each_line{|line|
    line.encode!("UTF-8", {:invalid => :replace, :undef => :replace, :univeral_newline => true}) if(FIX_ENCODING)
    line.chomp!
    if line.length > 0 then
      db.insert("links", {"uri" => line})
      count += 1
    end

    # Print some progress
    print "\r#{count}..." if (count % NOTIFY_PROGRESS) == 0
  }
  db.close
  puts "\nAdded #{count} link[s]."
rescue Exception => e
  $stderr.puts "Error: #{e}\n\n#{e.backtrace.join("\n")}."
end

